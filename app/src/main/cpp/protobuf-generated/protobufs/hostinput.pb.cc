// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protobufs/hostinput.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "protobufs/hostinput.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace HostBuffers {

void protobuf_ShutdownFile_protobufs_2fhostinput_2eproto() {
  HostMessage_default_instance_.Shutdown();
  Instruction_default_instance_.Shutdown();
  HostBytes_default_instance_.Shutdown();
  EchoAck_default_instance_.Shutdown();
}

void protobuf_InitDefaults_protobufs_2fhostinput_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::GetEmptyString();
  HostMessage_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  Instruction_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  HostBytes_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  EchoAck_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    ::HostBuffers::Instruction::internal_default_instance(),
    2, 11, false, false,
    ::HostBuffers::HostBytes::internal_default_instance());
  ::google::protobuf::internal::ExtensionSet::RegisterMessageExtension(
    ::HostBuffers::Instruction::internal_default_instance(),
    7, 11, false, false,
    ::HostBuffers::EchoAck::internal_default_instance());
  HostMessage_default_instance_.get_mutable()->InitAsDefaultInstance();
  Instruction_default_instance_.get_mutable()->InitAsDefaultInstance();
  HostBytes_default_instance_.get_mutable()->InitAsDefaultInstance();
  EchoAck_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_protobufs_2fhostinput_2eproto_once_);
void protobuf_InitDefaults_protobufs_2fhostinput_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_protobufs_2fhostinput_2eproto_once_,
                 &protobuf_InitDefaults_protobufs_2fhostinput_2eproto_impl);
}
void protobuf_AddDesc_protobufs_2fhostinput_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_protobufs_2fhostinput_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_protobufs_2fhostinput_2eproto_once_);
void protobuf_AddDesc_protobufs_2fhostinput_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_protobufs_2fhostinput_2eproto_once_,
                 &protobuf_AddDesc_protobufs_2fhostinput_2eproto_impl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_protobufs_2fhostinput_2eproto {
  StaticDescriptorInitializer_protobufs_2fhostinput_2eproto() {
    protobuf_AddDesc_protobufs_2fhostinput_2eproto();
  }
} static_descriptor_initializer_protobufs_2fhostinput_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

static ::std::string* MutableUnknownFieldsForHostMessage(
    HostMessage* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HostMessage::kInstructionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HostMessage::HostMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:HostBuffers.HostMessage)
}

void HostMessage::InitAsDefaultInstance() {
}

HostMessage::HostMessage(const HostMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HostBuffers.HostMessage)
}

void HostMessage::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

HostMessage::~HostMessage() {
  // @@protoc_insertion_point(destructor:HostBuffers.HostMessage)
  SharedDtor();
}

void HostMessage::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void HostMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HostMessage& HostMessage::default_instance() {
  protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<HostMessage> HostMessage_default_instance_;

HostMessage* HostMessage::New(::google::protobuf::Arena* arena) const {
  HostMessage* n = new HostMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HostMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:HostBuffers.HostMessage)
  instruction_.Clear();
  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HostMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForHostMessage, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:HostBuffers.HostMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .HostBuffers.Instruction instruction = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_instruction:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_instruction()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_instruction;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HostBuffers.HostMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HostBuffers.HostMessage)
  return false;
#undef DO_
}

void HostMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HostBuffers.HostMessage)
  // repeated .HostBuffers.Instruction instruction = 1;
  for (unsigned int i = 0, n = this->instruction_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->instruction(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:HostBuffers.HostMessage)
}

size_t HostMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HostBuffers.HostMessage)
  size_t total_size = 0;

  // repeated .HostBuffers.Instruction instruction = 1;
  {
    unsigned int count = this->instruction_size();
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->instruction(i));
    }
  }

  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HostMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HostMessage*>(&from));
}

void HostMessage::MergeFrom(const HostMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HostBuffers.HostMessage)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void HostMessage::UnsafeMergeFrom(const HostMessage& from) {
  GOOGLE_DCHECK(&from != this);
  instruction_.MergeFrom(from.instruction_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void HostMessage::CopyFrom(const HostMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HostBuffers.HostMessage)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool HostMessage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->instruction())) return false;
  return true;
}

void HostMessage::Swap(HostMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HostMessage::InternalSwap(HostMessage* other) {
  instruction_.UnsafeArenaSwap(&other->instruction_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HostMessage::GetTypeName() const {
  return "HostBuffers.HostMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HostMessage

// repeated .HostBuffers.Instruction instruction = 1;
int HostMessage::instruction_size() const {
  return instruction_.size();
}
void HostMessage::clear_instruction() {
  instruction_.Clear();
}
const ::HostBuffers::Instruction& HostMessage::instruction(int index) const {
  // @@protoc_insertion_point(field_get:HostBuffers.HostMessage.instruction)
  return instruction_.Get(index);
}
::HostBuffers::Instruction* HostMessage::mutable_instruction(int index) {
  // @@protoc_insertion_point(field_mutable:HostBuffers.HostMessage.instruction)
  return instruction_.Mutable(index);
}
::HostBuffers::Instruction* HostMessage::add_instruction() {
  // @@protoc_insertion_point(field_add:HostBuffers.HostMessage.instruction)
  return instruction_.Add();
}
::google::protobuf::RepeatedPtrField< ::HostBuffers::Instruction >*
HostMessage::mutable_instruction() {
  // @@protoc_insertion_point(field_mutable_list:HostBuffers.HostMessage.instruction)
  return &instruction_;
}
const ::google::protobuf::RepeatedPtrField< ::HostBuffers::Instruction >&
HostMessage::instruction() const {
  // @@protoc_insertion_point(field_list:HostBuffers.HostMessage.instruction)
  return instruction_;
}

inline const HostMessage* HostMessage::internal_default_instance() {
  return &HostMessage_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForInstruction(
    Instruction* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Instruction::Instruction()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:HostBuffers.Instruction)
}

void Instruction::InitAsDefaultInstance() {
}

Instruction::Instruction(const Instruction& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HostBuffers.Instruction)
}

void Instruction::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Instruction::~Instruction() {
  // @@protoc_insertion_point(destructor:HostBuffers.Instruction)
  SharedDtor();
}

void Instruction::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Instruction::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Instruction& Instruction::default_instance() {
  protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<Instruction> Instruction_default_instance_;

Instruction* Instruction::New(::google::protobuf::Arena* arena) const {
  Instruction* n = new Instruction;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Instruction::Clear() {
// @@protoc_insertion_point(message_clear_start:HostBuffers.Instruction)
  _extensions_.Clear();
  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool Instruction::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForInstruction, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:HostBuffers.Instruction)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    if ((16u <= tag)) {
      DO_(_extensions_.ParseField(tag, input, internal_default_instance(),
                                  &unknown_fields_stream));
      continue;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:HostBuffers.Instruction)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HostBuffers.Instruction)
  return false;
#undef DO_
}

void Instruction::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HostBuffers.Instruction)
  // Extension range [2, 536870912)
  _extensions_.SerializeWithCachedSizes(
      2, 536870912, output);

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:HostBuffers.Instruction)
}

size_t Instruction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HostBuffers.Instruction)
  size_t total_size = 0;

  total_size += _extensions_.ByteSize();

  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Instruction::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Instruction*>(&from));
}

void Instruction::MergeFrom(const Instruction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HostBuffers.Instruction)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void Instruction::UnsafeMergeFrom(const Instruction& from) {
  GOOGLE_DCHECK(&from != this);
  _extensions_.MergeFrom(from._extensions_);
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void Instruction::CopyFrom(const Instruction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HostBuffers.Instruction)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool Instruction::IsInitialized() const {


  if (!_extensions_.IsInitialized()) {
    return false;
  }
  return true;
}

void Instruction::Swap(Instruction* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Instruction::InternalSwap(Instruction* other) {
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
  _extensions_.Swap(&other->_extensions_);
}

::std::string Instruction::GetTypeName() const {
  return "HostBuffers.Instruction";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Instruction

inline const Instruction* Instruction::internal_default_instance() {
  return &Instruction_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForHostBytes(
    HostBytes* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HostBytes::kHoststringFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HostBytes::HostBytes()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:HostBuffers.HostBytes)
}

void HostBytes::InitAsDefaultInstance() {
}

HostBytes::HostBytes(const HostBytes& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HostBuffers.HostBytes)
}

void HostBytes::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hoststring_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

HostBytes::~HostBytes() {
  // @@protoc_insertion_point(destructor:HostBuffers.HostBytes)
  SharedDtor();
}

void HostBytes::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hoststring_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void HostBytes::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const HostBytes& HostBytes::default_instance() {
  protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<HostBytes> HostBytes_default_instance_;

HostBytes* HostBytes::New(::google::protobuf::Arena* arena) const {
  HostBytes* n = new HostBytes;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HostBytes::Clear() {
// @@protoc_insertion_point(message_clear_start:HostBuffers.HostBytes)
  if (has_hoststring()) {
    hoststring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HostBytes::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForHostBytes, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:HostBuffers.HostBytes)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes hoststring = 4;
      case 4: {
        if (tag == 34) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_hoststring()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HostBuffers.HostBytes)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HostBuffers.HostBytes)
  return false;
#undef DO_
}

void HostBytes::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HostBuffers.HostBytes)
  // optional bytes hoststring = 4;
  if (has_hoststring()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->hoststring(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:HostBuffers.HostBytes)
}

size_t HostBytes::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HostBuffers.HostBytes)
  size_t total_size = 0;

  // optional bytes hoststring = 4;
  if (has_hoststring()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->hoststring());
  }

  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HostBytes::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const HostBytes*>(&from));
}

void HostBytes::MergeFrom(const HostBytes& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HostBuffers.HostBytes)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void HostBytes::UnsafeMergeFrom(const HostBytes& from) {
  GOOGLE_DCHECK(&from != this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hoststring()) {
      set_has_hoststring();
      hoststring_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hoststring_);
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void HostBytes::CopyFrom(const HostBytes& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HostBuffers.HostBytes)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool HostBytes::IsInitialized() const {

  return true;
}

void HostBytes::Swap(HostBytes* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HostBytes::InternalSwap(HostBytes* other) {
  hoststring_.Swap(&other->hoststring_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string HostBytes::GetTypeName() const {
  return "HostBuffers.HostBytes";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HostBytes

// optional bytes hoststring = 4;
bool HostBytes::has_hoststring() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HostBytes::set_has_hoststring() {
  _has_bits_[0] |= 0x00000001u;
}
void HostBytes::clear_has_hoststring() {
  _has_bits_[0] &= ~0x00000001u;
}
void HostBytes::clear_hoststring() {
  hoststring_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hoststring();
}
const ::std::string& HostBytes::hoststring() const {
  // @@protoc_insertion_point(field_get:HostBuffers.HostBytes.hoststring)
  return hoststring_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void HostBytes::set_hoststring(const ::std::string& value) {
  set_has_hoststring();
  hoststring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HostBuffers.HostBytes.hoststring)
}
void HostBytes::set_hoststring(const char* value) {
  set_has_hoststring();
  hoststring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HostBuffers.HostBytes.hoststring)
}
void HostBytes::set_hoststring(const void* value, size_t size) {
  set_has_hoststring();
  hoststring_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HostBuffers.HostBytes.hoststring)
}
::std::string* HostBytes::mutable_hoststring() {
  set_has_hoststring();
  // @@protoc_insertion_point(field_mutable:HostBuffers.HostBytes.hoststring)
  return hoststring_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* HostBytes::release_hoststring() {
  // @@protoc_insertion_point(field_release:HostBuffers.HostBytes.hoststring)
  clear_has_hoststring();
  return hoststring_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void HostBytes::set_allocated_hoststring(::std::string* hoststring) {
  if (hoststring != NULL) {
    set_has_hoststring();
  } else {
    clear_has_hoststring();
  }
  hoststring_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hoststring);
  // @@protoc_insertion_point(field_set_allocated:HostBuffers.HostBytes.hoststring)
}

inline const HostBytes* HostBytes::internal_default_instance() {
  return &HostBytes_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

static ::std::string* MutableUnknownFieldsForEchoAck(
    EchoAck* ptr) {
  return ptr->mutable_unknown_fields();
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EchoAck::kEchoAckNumFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EchoAck::EchoAck()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:HostBuffers.EchoAck)
}

void EchoAck::InitAsDefaultInstance() {
}

EchoAck::EchoAck(const EchoAck& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:HostBuffers.EchoAck)
}

void EchoAck::SharedCtor() {
  _cached_size_ = 0;
  _unknown_fields_.UnsafeSetDefault(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  echo_ack_num_ = GOOGLE_ULONGLONG(0);
}

EchoAck::~EchoAck() {
  // @@protoc_insertion_point(destructor:HostBuffers.EchoAck)
  SharedDtor();
}

void EchoAck::SharedDtor() {
  _unknown_fields_.DestroyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EchoAck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const EchoAck& EchoAck::default_instance() {
  protobuf_InitDefaults_protobufs_2fhostinput_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<EchoAck> EchoAck_default_instance_;

EchoAck* EchoAck::New(::google::protobuf::Arena* arena) const {
  EchoAck* n = new EchoAck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void EchoAck::Clear() {
// @@protoc_insertion_point(message_clear_start:HostBuffers.EchoAck)
  echo_ack_num_ = GOOGLE_ULONGLONG(0);
  _has_bits_.Clear();
  _unknown_fields_.ClearToEmptyNoArena(
      &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool EchoAck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::LazyStringOutputStream unknown_fields_string(
      ::google::protobuf::NewPermanentCallback(
          &MutableUnknownFieldsForEchoAck, this));
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string, false);
  // @@protoc_insertion_point(parse_start:HostBuffers.EchoAck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 echo_ack_num = 8;
      case 8: {
        if (tag == 64) {
          set_has_echo_ack_num();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &echo_ack_num_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:HostBuffers.EchoAck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:HostBuffers.EchoAck)
  return false;
#undef DO_
}

void EchoAck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:HostBuffers.EchoAck)
  // optional uint64 echo_ack_num = 8;
  if (has_echo_ack_num()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->echo_ack_num(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   static_cast<int>(unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:HostBuffers.EchoAck)
}

size_t EchoAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:HostBuffers.EchoAck)
  size_t total_size = 0;

  // optional uint64 echo_ack_num = 8;
  if (has_echo_ack_num()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->echo_ack_num());
  }

  total_size += unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void EchoAck::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const EchoAck*>(&from));
}

void EchoAck::MergeFrom(const EchoAck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:HostBuffers.EchoAck)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void EchoAck::UnsafeMergeFrom(const EchoAck& from) {
  GOOGLE_DCHECK(&from != this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_echo_ack_num()) {
      set_echo_ack_num(from.echo_ack_num());
    }
  }
  if (!from.unknown_fields().empty()) {
    mutable_unknown_fields()->append(from.unknown_fields());
  }
}

void EchoAck::CopyFrom(const EchoAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:HostBuffers.EchoAck)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool EchoAck::IsInitialized() const {

  return true;
}

void EchoAck::Swap(EchoAck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EchoAck::InternalSwap(EchoAck* other) {
  std::swap(echo_ack_num_, other->echo_ack_num_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string EchoAck::GetTypeName() const {
  return "HostBuffers.EchoAck";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// EchoAck

// optional uint64 echo_ack_num = 8;
bool EchoAck::has_echo_ack_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void EchoAck::set_has_echo_ack_num() {
  _has_bits_[0] |= 0x00000001u;
}
void EchoAck::clear_has_echo_ack_num() {
  _has_bits_[0] &= ~0x00000001u;
}
void EchoAck::clear_echo_ack_num() {
  echo_ack_num_ = GOOGLE_ULONGLONG(0);
  clear_has_echo_ack_num();
}
::google::protobuf::uint64 EchoAck::echo_ack_num() const {
  // @@protoc_insertion_point(field_get:HostBuffers.EchoAck.echo_ack_num)
  return echo_ack_num_;
}
void EchoAck::set_echo_ack_num(::google::protobuf::uint64 value) {
  set_has_echo_ack_num();
  echo_ack_num_ = value;
  // @@protoc_insertion_point(field_set:HostBuffers.EchoAck.echo_ack_num)
}

inline const EchoAck* EchoAck::internal_default_instance() {
  return &EchoAck_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS
::google::protobuf::internal::ExtensionIdentifier< ::HostBuffers::Instruction,
    ::google::protobuf::internal::MessageTypeTraits< ::HostBuffers::HostBytes >, 11, false >
  hostbytes(kHostbytesFieldNumber, *::HostBuffers::HostBytes::internal_default_instance());
::google::protobuf::internal::ExtensionIdentifier< ::HostBuffers::Instruction,
    ::google::protobuf::internal::MessageTypeTraits< ::HostBuffers::EchoAck >, 11, false >
  echoack(kEchoackFieldNumber, *::HostBuffers::EchoAck::internal_default_instance());

// @@protoc_insertion_point(namespace_scope)

}  // namespace HostBuffers

// @@protoc_insertion_point(global_scope)
